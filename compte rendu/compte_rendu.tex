\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[frenchkw]{algorithm2e}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}

%opening
\title{}
\author{}

\begin{document}

\maketitle

\begin{abstract}
%a la fin
\end{abstract}

\section{Qu'est ce qu'un système de recommandation?}
\subsection{Notre approche}
Le but de notre projet est de recommander un film à un utilisateur spécifique. 
Pour cela, nous devons savoir à quel point un utilisateur aime tel ou tel film pour lui recommander (ou pas). 
Il nous faudrait donc une sorte d'échelle d'affinité de l'utilisateur au film, ce qui parait pertinent est donc d'estimer une note qu'un utilisateur mettrait à un film s'il avait à le noter par exemple. 
Si cette note est au dessus d'un certain seuil, on lui recommandera (ou on recommandera le film ayant la meilleur note prédite par exemple). 
Notre approche du problème est donc de trouver un modèle mathématique permettant de trouver la note que mettrait un utilisateur à un film qu'il n'a pas vu. 
Cependant, sans aucunes connaissances des gouts l'utilisateur et des caractéristiques des films ceci est impossible. Il nous faut donc récuperer des données déjà existentes sur des utilisatuers et des films pour avoir une base et commencer à chercher une méthode.  
Nous avons donc récuperer des données.

\subsection{Première difficulté : les données}
\subsubsection{Extraction des données}
Le besoin d'avoir des données nous à guider vers une grande base de données appelé `` movielens '' qui est un site communautaire de recommandation de films où les utilisateurs du site notent des films de 0 à 5. 
Plusieurs jeux de données étaient disponibles et différé entre eux selon leur taille, 
Nous avons choisi de travailler avec une base de données de 670 utilisateurs (nu) et 9125 films (nf). 
On a donc extrait 2 fichiers : l’un contenant les 9125 films avec leurs titres et un numéro attribué , 
l’autre avec les notes des utilisateurs qui avaient chacun un identifiants, 
le fichier était du type : identifiant de l’utilisateur, id du film qu’il a noté, note.
Ces 2 fichiers étaient donc peu pratiques pour commencer à faire quelque chose avec, 
nous avons donc créer une fonction tableau\_des\_notes() qui permet de ranger toutes ces notes dans un tableau numpy nu*nf avec en lignes les utilisateurs, 
et en colonnes les films. Quand un utilisateur n’a pas vu un film donc qu’il ne l’a pas noté, 
on insère un `` Nan ''(Not a Number) qui est un `` symbole '' facile à traiter. On appellera ce tableau Y tout au long du projet.

\subsubsection{Analyse des données}
\subsection{}
\section{Formalisation du problème d'optimisation y compris modélisation}

Nous nous posons maintenant la question comment nous y prendre pour prédire des notes ?
Notre seul ressource est la matrice Y non pleine, sur quel modèle s'appuyer pour la compléter ?
C'est ce que nous allons étudier dans cette partie.

\subsection{Factorisation}

Posons $Y_f$ la matrice Y complétée qui contient toutes les prédictions, exactes, des notes qui nous manquent. C'est la matrice à laquelle nous voulons aboutir, que nous devons deviner. Voici notre méthode.

Nous supposons que nous sommes capable de déterminer (et nous verrons que nous le somme) à partir de Y deux matrices X et $\Theta$ telles que $\Theta X^T = Y_f$ avec $\Theta$ une matrice de dimension $n_u * n$ et X une matrice de dimension $n_f*n$. $n\in\mathbb{N}^*$




\subsection{Fonction cout}
%toujours antho
\subsubsection{Pourquoi on cherche a minimiser}
\section{Implémentation algo}
%guillaume
\subsection{descente du gradient en general optimisation}
Nous utilisons un algorithme appelé descente du gradient pour minimiser J. L'idée dérriere la descente du gradient
est de descendre la pente de al fonction donc le gradient que nous nommons $\nabla_{x}$ pour le gradiant de la fonction par rapport
a $x$. Une explication plus détaillé de la notation est donné en annexe. 


\begin{algorithm}[H]
 \Donnees{a mettre}
 \Res{un nouveau x}
 initialization\;
 \Repeter{not at end of this document}{
  read current\;
  \eSi{understand}{
   go to next section\;
   current section becomes this one\;
   }{
   go back to the beginning of current section\;
  }
 }
 \pourTous{}{}
 \caption{How to write algorithms}
\end{algorithm}
\subsubsection{ecrire algo puis dire comment on a fait au début}
\section{Mise en application}
\subsection{Notre approche pour familiariser au probleme}
%juliette
\subsection{yassine}
\subsubsection{taux d'erreur}
\subsubsection{influence des parametres}
\subsection{limites de notre approche}
%yassine
\subsubsection{Est-ce qu'on arrive a reccomander un film a un utilisateur}
%guillaume
\section{conclusion}
%1 page

\subsection{perspectives}
%guillame
\appendix
\section{notations utilisé}
\subsection{gradient}
\end{document}